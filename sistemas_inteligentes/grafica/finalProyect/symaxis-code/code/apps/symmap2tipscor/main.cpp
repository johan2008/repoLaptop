#include <vector>
#include <iostream>
#include "R3Shapes/R3Shapes.h"
#include <fstream>
using namespace std;

////////////////////////////////////////////////////////////////////////
// Program: SymmetricMap2TipsCor
// Input 1: mesh(.off)
// Input 2: a set of tips (.pid). 
// Input 3: dense map(.map), generated by BIM, a non-identical map takes 
// a model to itself
// Input 4: an axis, extracted from the map also (to tell the order in a
//  pair)
// Output: a file describe pairs and singletons (order is defined within
//  a pair).
// To couple tips based a symmetric map
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// Input file name
////////////////////////////////////////////////////////////////////////

char * input_mesh_name = NULL;
char * input_tips_name = NULL;
char * input_symmap_name = NULL;
char * input_axis_name = NULL;
char * output_symcorr_name = NULL;

////////////////////////////////////////////////////////////////////////
// Data structure
////////////////////////////////////////////////////////////////////////

R3Mesh * Mesh = NULL;
RNArray<R3MeshVertex*>* Tips = NULL;
struct DenseVertexCorrespondence {
  	R3Mesh *mesh[2];
  	R3MeshVertex **vertices; 
  	DenseVertexCorrespondence(R3Mesh *mesh0, R3Mesh *mesh1) { 
    	mesh[0] = mesh0; 
    	mesh[1] = mesh1; 
    	vertices = new R3MeshVertex * [ mesh0->NVertices() ];
    	for (int i = 0; i < mesh0->NVertices(); i++) vertices[i] = NULL;
  	};
};
DenseVertexCorrespondence* SymMap = NULL;
RNArray<R3MeshVertex*>* Axis = NULL;
// Sides on the surface based on the symmetry axis
int * Sides = NULL;

struct Elem
{
	// Flag: on if it is a pair
	int isPair;
	R3MeshVertex* vertex[2];
};
RNArray<Elem*>* PointsRecorder = NULL;

////////////////////////////////////////////////////////////////////////
// Flags
////////////////////////////////////////////////////////////////////////

int print_verbose = 0;
int print_debug = 0;

////////////////////////////////////////////////////////////////////////
// Variables
////////////////////////////////////////////////////////////////////////
// Threshold to tell a point if it is on the axis
RNScalar thres = 0.1;

////////////////////////////////////////////////////////////////////////
// Input functions
////////////////////////////////////////////////////////////////////////

// Mesh
static R3Mesh *
ReadMesh(char *filename)
{
  	// Start statistics
  	RNTime start_time;
  	start_time.Read();

  	// Allocate mesh
  	R3Mesh *mesh = new R3Mesh();
  	assert(mesh);

  	// Read mesh from file
  	if (!mesh->ReadFile(filename)) {
    	fprintf(stderr, "Unable to read mesh from %s\n", filename);
    	return NULL;
  	}

  	// Print statistics
  	if (print_verbose) {
    	printf("Read mesh from %s ...\n", filename);
    	printf("  Time = %.2f seconds\n", start_time.Elapsed());
    	printf("  # Faces = %d\n", mesh->NFaces());
    	printf("  # Edges = %d\n", mesh->NEdges());
    	printf("  # Vertices = %d\n", mesh->NVertices());
    	fflush(stdout);
  	}

  	// Return success
  	return mesh;
}

// Points
static RNArray<R3MeshVertex*>*
ReadPoints(R3Mesh* mesh, const char* filename)
{
	RNArray<R3MeshVertex*>* axis = new RNArray<R3MeshVertex*>;
	ifstream fin(filename);
	if (!fin)
	{
		cout<<"Cannot open point file "<<filename<<endl;
		exit(-1);
	}
	int temp;
	while (fin>>temp)
	{
		axis->Insert(mesh->Vertex(temp));
	}
	fin.close();
	return axis;
}

// Dense Correspondence
static DenseVertexCorrespondence *
ReadDenseVertexCorrespondence(R3Mesh* mesh0, R3Mesh* mesh1, char* filename)
{
	// Create Dense Correspondence
	DenseVertexCorrespondence* map = new DenseVertexCorrespondence(mesh0, mesh1);

	// Open file
	ifstream fin(filename);
	if (!fin)
	{
		printf("Cannot open file for reading dense correspondence : %s\n", filename);
		delete map;
		return NULL;
	}
	int temp;
	int counter = 0;
	while (fin >> temp)
	{
		if (counter >= mesh0->NVertices())
		{
			printf("Map file does not match to Mesh : %s\n", filename);
			delete map;
			fin.close();
			return NULL;
		}
		map->vertices[counter] = mesh1->Vertex(temp);
		counter ++;
	}

	if (counter != mesh0->NVertices())
	{
		printf("Map file does not match Mesh : %s\n", filename);
		delete map;
		fin.close();
		return NULL;
	}
	
	fin.close();
	return map;
}

// Compute sides based on the axis
// Val = 1: ccw (or right on the axis)
// Val = -1: cw
static int*
CreateSides(R3Mesh* mesh, RNArray<R3MeshVertex*>* axis)
{
	int * sides = new int [mesh->NVertices()];
	for (int i=0; i<mesh->NVertices(); i++) sides[i] = -1;

	RNArray<R3MeshEdge*> axis_edges;
	for (int i=0; i<axis->NEntries(); i++)
	{
		R3MeshVertex* v[2];
		v[0] = axis->Kth(i);
		v[1] = axis->Kth((i+1)%axis->NEntries());

		R3MeshEdge* edge = mesh->EdgeBetweenVertices(v[0], v[1]);
		if (edge)
			axis_edges.Insert(edge);
		else 
		{
			cout<<"Axis is disconnected!"<<endl;
			exit(-1);
		}
	}

	// Prepare : set all vertices to be intial
	R3mesh_mark ++;
	int init_mark = R3mesh_mark;
	for (int i=0; i<mesh->NVertices(); i++)
		mesh->SetVertexMark(mesh->Vertex(i), init_mark);
	// Preparation: Mark the vertices on axis
	R3mesh_mark ++;
	int axis_mark = R3mesh_mark;
	for (int i=0; i<axis->NEntries(); i++)
	{
		mesh->SetVertexMark(axis->Kth(i), axis_mark);
	}
	R3mesh_mark ++;
	int cw_mark = R3mesh_mark;
	R3mesh_mark ++;
	int ccw_mark = R3mesh_mark;
	int idx = 0;
	while (idx < axis->NEntries())
	{
		R3MeshVertex* seed = NULL;
		R3MeshVertex* vertex = axis->Kth(idx);
		R3MeshEdge* edge = axis_edges.Kth(idx);
		edge = mesh->EdgeOnVertex(vertex, edge, RN_CCW);
		if (!edge) {idx++;continue;}
		seed = mesh->VertexAcrossEdge(edge, vertex);
		if (!seed) {idx++;continue;}
		if (mesh->VertexMark(seed) == axis_mark) // another axis edge
		{ idx++;continue; }
		if (mesh->VertexMark(seed) == ccw_mark) // alread marked
		{ idx++;continue;}
		else if (mesh->VertexMark(seed) == cw_mark)
		{
			cout<<"ccw to cw conflict (init)!"<<endl;
			cout<<idx<<endl;
			if (print_debug)
				getchar();
			idx++;
			continue;
		}
		RNArray<R3MeshVertex*> stack;
		stack.Insert(seed);
		mesh->SetVertexMark(seed, ccw_mark);
		while (!stack.IsEmpty())
		{
			R3MeshVertex* vertex = stack.Tail();
			stack.RemoveTail();
			for (int i=0; i<mesh->VertexValence(vertex); i++)
			{
				R3MeshEdge* edge = mesh->EdgeOnVertex(vertex, i);
				R3MeshVertex* neighbor = mesh->VertexAcrossEdge(edge, vertex);
				if (!neighbor) continue;
				if (mesh->VertexMark(neighbor) == ccw_mark)
					continue;
				if (mesh->VertexMark(neighbor) == cw_mark)
				{
					cout<<"ccw to cw conflict!"<<endl;
					cout<<idx<<endl;
					if (print_debug)
						getchar();
				}
				// set new mark
				if (mesh->VertexMark(neighbor) == init_mark)
				{
					stack.Insert(neighbor);
					mesh->SetVertexMark(neighbor, ccw_mark);
				}
			}
		}
		// cw
		vertex = axis->Kth(idx);
		edge = axis_edges.Kth(idx);
		edge = mesh->EdgeOnVertex(vertex, edge, RN_CW);
		if (!edge) {idx++;continue;}
		seed = mesh->VertexAcrossEdge(edge, vertex);
		if (!seed) {idx++;continue;}
		if (mesh->VertexMark(seed) == axis_mark) // another axis edge
		{idx++;continue;}
		if (mesh->VertexMark(seed) == cw_mark) // alread marked
		{idx++;continue;}
		else if (mesh->VertexMark(seed) == ccw_mark)
		{
			cout<<"cw to ccw conflict (init)!"<<endl;
			cout<<idx<<endl;
			if (print_debug)
				getchar();
			idx++;
			continue;
		}
		stack.Empty();
		stack.Insert(seed);
		mesh->SetVertexMark(seed, cw_mark);
		while (!stack.IsEmpty())
		{
			R3MeshVertex* vertex = stack.Tail();
			stack.RemoveTail();
			for (int i=0; i<mesh->VertexValence(vertex); i++)
			{
				R3MeshEdge* edge = mesh->EdgeOnVertex(vertex, i);
				R3MeshVertex* neighbor = mesh->VertexAcrossEdge(edge, vertex);
				if (!neighbor) continue;
				if (mesh->VertexMark(neighbor) == cw_mark)
					continue;
				if (mesh->VertexMark(neighbor) == ccw_mark)
				{
					cout<<"cw to ccw conflict!"<<endl;
					cout<<idx<<endl;
					if (print_debug)
						getchar();
				}
				// set new mark
				if (mesh->VertexMark(neighbor) == init_mark)
				{
					stack.Insert(neighbor);
					mesh->SetVertexMark(neighbor, cw_mark);
				}
			}
		}
		idx ++;
	}	

	for (int i=0; i<mesh->NVertices(); i++)
	{
		R3MeshVertex* vertex = mesh->Vertex(i);
		if (mesh->VertexMark(vertex) == ccw_mark)
		{
			sides[i] = 1;
		}
		else if (mesh->VertexMark(vertex) == cw_mark)
		{
			sides[i] = -1;
		}
		else if (mesh->VertexMark(vertex) == axis_mark)
		{
			sides[i] = 1;
		}
		else if (mesh->VertexMark(vertex) == init_mark)
		{
			cout<<"still init_mark!"<<endl;
			cout<<i<<endl;
			getchar();
		}
		else
		{
			cout<<"Should not be such a mark!"<<endl;
			cout<<i<<endl;
			getchar();
		}
	}
	return sides;
}

////////////////////////////////////////////////////////////////////////
// Argument Parser
////////////////////////////////////////////////////////////////////////

static int
ParseArgs(int argc, char ** argv)
{
	// Parse arguments
    argc--; argv++;
    while (argc > 0) {
        if ((*argv)[0] == '-') {
            if (!strcmp(*argv, "-v")) print_verbose = 1;
        	else if (!strcmp(*argv, "-debug")) print_debug = 1;
			else if (!strcmp(*argv, "-thres"))
			{
				argc--; argv++;
				thres = atof(*argv);
			}
        	else { fprintf(stderr, "Invalid program argument: %s", *argv); exit(1); }
        	argv++; argc--;
    	}
    	else {
        	if (!input_mesh_name) input_mesh_name = *argv;
			else if (!input_tips_name) input_tips_name = *argv;
			else if (!input_symmap_name) input_symmap_name = *argv;
			else if (!input_axis_name) input_axis_name = *argv;
			else if (!output_symcorr_name) output_symcorr_name = *argv;
			else { fprintf(stderr, "Invalid program argument: %s", *argv); exit(1); }
        	argv++; argc--;
    	}
  	}
	// Check input filename
  	if (!input_mesh_name || !input_tips_name || !input_symmap_name || !input_axis_name
			|| !output_symcorr_name) {
    	fprintf(stderr, "Usage: SymmetricMap2TipsCor mesh tips symmap axis symcorr [-v, -debug, -thres RNScalar (0.1 by default)]\n");
    	return 0;
  	}

	return 1;
}

static RNArray<Elem*>*
FindCorrespondences(R3Mesh* mesh, int* sides, DenseVertexCorrespondence* symmap, RNArray<R3MeshVertex*>* tips)
{
	RNArray<Elem*>* recorder = new RNArray<Elem*>;
	int ntips = tips->NEntries();
	int * visited = new int[ntips];
	for (int i=0; i<ntips; i++)
		visited[i] = 0;

	int singleton_counter = 0;
	int pair_counter = 0;
	for (int i=0; i<ntips; i++)
	{
		if (visited[i])
			continue;
		visited[i] = 1;
		R3MeshVertex* candidate = tips->Kth(i);
		R3MeshVertex* corr = symmap->vertices[mesh->VertexID(candidate)];
		R3MeshVertex* corr_tip = NULL;
		int corr_tip_idx = -1;
		RNLength shortest_dist = thres;
		for (int j=0; j<ntips; j++)
		{
			RNLength dist = mesh->DijkstraDistance(corr, tips->Kth(j));
			if (dist < shortest_dist)
			{
				shortest_dist = dist;
				corr_tip = tips->Kth(j);
				corr_tip_idx = j;
			}
		}

		// Solitude point
		if (!corr_tip)
		{
			if (print_debug)
			{
				cout<<"No mapped tip for tip idx = "<<i<<endl;
			}
			continue;
		}
		// Singleton
		if (corr_tip == candidate)
		{
			Elem* elem = new Elem;
			elem->isPair = 0;
			elem->vertex[0] = candidate;
			elem->vertex[1] = candidate;
			recorder->Insert(elem);
			singleton_counter ++;
		}
		else
		{
			// Possible to be in a pair
			R3MeshVertex* cand2 = corr_tip;
			// If have been visited
			if (visited[corr_tip_idx])
				continue;
			R3MeshVertex* corr2 = symmap->vertices[mesh->VertexID(cand2)];
			corr_tip = NULL;
			for (int j=0; j<ntips; j++)
			{
				RNLength dist = mesh->DijkstraDistance(corr2, tips->Kth(j));
				if (dist < shortest_dist)
				{
					shortest_dist = dist;
					corr_tip = tips->Kth(j);
				}
			}
			if (!corr_tip || corr_tip == candidate)
			{
				// it is mutually closest
				visited[corr_tip_idx] = 1;
				Elem* elem = new Elem;
				elem->isPair = 1;
				if (sides[mesh->VertexID(candidate)] == 1 &&
				  sides[mesh->VertexID(cand2)] == -1 )
				{
					elem->vertex[0] = candidate;
					elem->vertex[1] = cand2;
				}
				else if (sides[mesh->VertexID(candidate)] == -1 &&
				  sides[mesh->VertexID(cand2)] == 1)
				{
					elem->vertex[0] = cand2;
					elem->vertex[1] = candidate;
				}
				recorder->Insert(elem);
				pair_counter ++;
			}
		}
	}
	
	if (print_verbose)
	{
		cout<<"#Pairs : "<<pair_counter<<endl;
		cout<<"#Singletons: "<<singleton_counter<<endl;
		cout<<"#Waste : "<<ntips-2*pair_counter-singleton_counter<<endl;
	}
	delete[] visited;
	return recorder;
}

int main(int argc, char ** argv)
{
	if (!ParseArgs(argc, argv)) exit(1);

	// Mesh
	Mesh = ReadMesh(input_mesh_name);

	// Tips
	Tips = ReadPoints(Mesh, input_tips_name);

	// Symmetry map
	SymMap = ReadDenseVertexCorrespondence(Mesh, Mesh, input_symmap_name);

	// Symmetry axis
	Axis = ReadPoints(Mesh, input_axis_name);	

	// Compute sides
	Sides = CreateSides(Mesh, Axis);
	if (print_debug)
	{
		R3MeshProperty * side_prp = new R3MeshProperty(Mesh);
		for (int i=0; i<Mesh->NVertices(); i++)
		{
			if (Sides[i] == 1)
				side_prp->SetVertexValue(i, 1.0);
			else if (Sides[i] == -1)
				side_prp->SetVertexValue(i, -1.0);
		}
		side_prp->Write("sides.val");
	}

	// Search for pairs and singletons
	PointsRecorder = FindCorrespondences(Mesh, Sides, SymMap, Tips);

	// Write to file
	ofstream fout(output_symcorr_name);
	for (int i=0; i<PointsRecorder->NEntries(); i++)
	{
		Elem* elem = PointsRecorder->Kth(i);
		if (elem->isPair)
			fout<<Mesh->VertexID(elem->vertex[0])<<" "<<Mesh->VertexID(elem->vertex[1])<<endl;
	}
	for (int i=0; i<PointsRecorder->NEntries(); i++)
	{
		Elem* elem = PointsRecorder->Kth(i);
		if (!elem->isPair)
			fout<<Mesh->VertexID(elem->vertex[0])<<" "<<Mesh->VertexID(elem->vertex[1])<<endl;
	}
	fout.close();
	return 0;
}
